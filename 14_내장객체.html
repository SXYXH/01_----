<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>내장객체</title>
<link rel="icon" href="data:,">
</head>
<body>
	<h1>내장객체</h1>
	- 문자, 날짜, 배열, 수학 개체 등이 있다. <br>
	- 주로 new 연산자를 활용하여 객체화 한다. <br>
	
	<h2>날짜 내장객체</h2>
	- 날짜 정보를 얻거나, 날짜 정보에 관련된 작업을 할때 쓰인다. <br>
	- 날짜의 정보는 사용자의 컴퓨터의 시간을 참조한다. <br>
	- 구문 : let date = new Date(); <br>
	- 1000의 정수값은 1초이다. <br>
	
	<script type="text/javascript">
		const date1 = new Date();
		const date2 = new Date('2024-04-19');
		const date3 = new Date(2024, 5, 35);
		const date4 = new Date('2024-04-19 09:00:00');
		console.log(date1);
		console.log(date2);
		console.log(date3);
		console.log(date4);

		// 날짜 일 간격
		const diff = (date2 - date1) / 1000 / 60 / 60 / 24;
		console.log(diff);
	</script>
	
	<h3>날짜객체 메서드 종류</h3>
	<script type="text/javascript">
	
		// 실습1. 오늘 날짜를 '2024년 00월 00일 (요일)' 이라고 출력하시오.
		
		function formatDate(insertDate){
			const fullYear = insertDate.getFullYear();
			const month = insertDate.getMonth() +1;
			const date = insertDate.getDate();
			const day = insertDate.getDay();
			const dayArr = ['일','월','화','수','목','금','토'];
			const result = `${fullYear}년 ${month}월 ${date}일 ${dayArr[day]}요일`;
			return result;
		}	
		console.log(formatDate(date1));

		// 실습2. 오늘 날짜에서 25일이 지난 날짜를 위의 포맷 방식으로 출력하시오.

		const addDate = new Date();
		addDate.setDate(date1.getDate() + 25);
		console.log(formatDate(addDate));



	</script>
	
	<h2>수학 객체</h2>
	- 난수, 반올림, 내림, 올림, 절댓값 등의 기능을 가진 객체
	<script>
		let num = -2.1234;
		let result= 0;
		// 절대값을 반환하는 메소드 :abs
		result = Math.abs(num);
		console.log(result);

		// 최대값을 반환하는 메소드 : max
		result = Math.max(1,2,3,4);
		console.log(result);

		const numArr = [1,2,3,4]
		result = Math.max(...numArr); // 스프레드 문법 -> ... <- 배열요소 목록 표현
		console.log(result);

		//최소값을 반환하는 메소드 : min
		result = Math.min(...numArr);
		console.log(result)

		//숫자의 거듭제곱값을 반환 : pow

		result = Math.pow(2,3);
		console.log(result);
		// console.log(2**3);  <- 이거도 똑같은 결과 (2의 3승)
		
		// 난수 추출 : random
		result = Math.random();
		console.log(result); // 0과 1사이값중 난수발생

		//소수점 반올림 : round
		result = Math.round(num);
		console.log(result)
		result= Math.round(num*10)/10; 
		console.log(result);

		//소수점 올림
		result = Math.ceil(num);
		console.log(result);

		//소수점 내림
		result = Math.floor(num);
		console.log(result);


		// 난수 추출 Math.random() 1~45 1게임 : 6 
		// 실습1. 로또 번호 추출 (중복번호 없이)
		//1게임당 1000원 = 10000원은 10게임

		const game = [];
		let gameMoney = 1000;
		
		while(game.length<6){
			const gamenum =Math.floor(Math.random()*45)+1;
			if(!game.includes(gamenum)){
				game.push(gamenum);
			}	
		}
		console.log(game);
		/*
		for(let i =0;i <(gameMoney *6 / 1000);i++){
			result = Math.floor(Math.random()*45)+1;
			game.push(result);
		}
		console.log(game);
		*/
	</script>

	<h2>배열 객체</h2>
	- 하나의 저장소의 공간을 나누어 데이터를 저장하는 객체 <br>
	- 배열의 요소의 주소는 index이며, 0번 부터 시작한다. <br>
	- 배열객체의 메서드 종류 <br>
	1) push() -> 인덱스 마지막 부터 데이터 저장과 인덱스 자동 증가 <br>
	2) unshift() -> 인덱스 0번째에 데이터 저장 (데이터 밀림) <br>
	3) pop() - > 배열의 마지막 번째 데이터 제거 <br>
	4) shift() -> 인덱스 0번째 데이터 제거 (데이터 당김)
	5) unshift() : 배열의 처음 요소로 값을 삽입하는 메소드<br>
	6) splice(삭제를 시작할 인덱스, 삭제할 요소수) : 특정배열 요소 삭제 <br>
	7) Array.isArray(배열 변수명) : 배열 여부 확인<br>	
	<script>
		const arr = [1,2,3,4];
		const obj={ name : '길동'};

		// 배열 여부확인 Array.isArray(데이터)(배열일 경우: true반환, 배열이 아닐경우: false반환)
		result =Array.isArray(arr);
		console.log(result);
		result =Array.isArray(arr);
		console.log(result);

		// 배열 요소 인덱스반환 [해당배열].indexOf(찾으려는 요소값)
		// 요소가 있으면 : 배열 요소의 인덱스(배열주소) 반환
		// 요소가 없으면 : -1 반환
		result = arr.indexOf(3);
		console.log(result);
		result = arr.indexOf(5);
		console.log(result);

		let searchValue = 4;
		if(arr.indexOf(searchValue) > -1){
			console.log(`${searchValue}는 arr의 요소에 있다`);
		}
		// push and pop
		// stack 자료구조 사용(last in first out)
		result = arr.push(5); // 마지막에 값추가
		console.log(arr);

		result = arr.pop() //마지막값 뺴기
		console.log(result)
		// unshift and shift
		result = arr.unshift(-1,0); //첫번째에 값추가
		console.log(result);
		console.log(arr);

		result = arr.shift(); //첫번째값 뺴기
		console.log(result);
		console.log(arr);

		// concat : 2개의 배열을 하나로 합치고 새로운 배열을 반환(순수함수) - > 기존자료형을 지킬 수 있따
		const arr1 =[1,2,3];
		const arr2 =[4,5,6];
		result = arr1.concat(arr2);
		console.log(result); // result는 123456을 담은 새로운 배열 , arr1 은 그대로 123 / arr2는 그대로 456을 가지고있는 상태

		// splice (시작할 인덱스, 제거할 요소수, 추가할 요소...)
		// 메소드 호출후 제거한 요소가 담긴 배열로 반환
		result = arr.splice(0,1);
		console.log(result);
		console.log(arr);

		result = arr.splice(2,0,5);
		console.log(result);
		console.log(arr);

		// slice (복사를 시작할 인덱스, 종료 인덱스 미만)
		result = arr.slice(0,2);
		console.log(result);
		console.log(arr); //기존자료형 변동사항없음

		// 인수가 없을 시 새로운 배열을 반환하여 요소 복사
		// 복사하는 요소가 객체타입일 경우 얕은 복사

		result = arr.slice(0);
		console.log(result); //종료인덱스 없을시 시작~ 끝까지 다복사

		result = arr.slice();
		console.log(result); //시작 종료 인덱스 없을시 전체복사

		// flat 배열의 평탄화 (인수가 없을 시에는 default 1)
		const flatArr = [1,[2,[3,[4]]]];
		result = flatArr.flat();
		console.log(flatArr);
		console.log(result);

		result = flatArr.flat(2);
		console.log(result);

		result = flatArr.flat(Infinity); //모든 배열 평탄화
		console.log(result);

		//reverse 배열의 요소 순서를 거꾸로 바꾼후 반환
		arr.reverse()
		console.log(arr);




		//고차 함수 계열
		//sort -1:작은수, 0:정렬안함, +1: 큰수
		const sortArr = [100, 30 ,24 , 88 ,45 ,66];
		//오름차순 정렬
		sortArr.sort((a,b) => a-b);
		console.log(sortArr);
		//내림차순 정렬
		sortArr.sort((a,b) => b-a);
		console.log(sortArr);

		//문자일 경우
		const sortArrStr = ['가','다','라','나','a'];
		//오름차순
		sortArrStr.sort();
		console.log(sortArrStr);
		//내림차순
		sortArrStr.sort();
		sortArrStr.reverse();
		console.log(sortArrStr);



		// map 요소 수 대로 순회하면서 콜백함수를 실행
		// return 된 값을 새로운 배열에 담아 반환
		const mapArr1 = [1,2,3,4];
		mapArr1.map(function(element, index, arr){
			console.log(`요소 : ${element}, idx : ${index}, target : ${arr}`);
		});

		const mapresult = mapArr1.map(element => element * 2);
		console.log(mapresult);

		const mapArr2 = ['이동근','이희상','고윤영','송영호','박중연'];
		const mapresult2 = mapArr2.map(name => `${name}님`);
		console.log(mapresult2)

		//구현
		const mapArr33 = [1,2,3,4];
		Array.prototype.mapLike = function(callback){
			const mapArr3 = [];
/*
			for(let i =0; i <this.length;i++){
				//const element = callback(this[i],i.this);
				//mapArr3.push(element);
				mapArr3.push(callback(this[i], i, this));
			}
*/
			
			for(let element of mapArr2){
				mapArr3.push(element + '님');
			}
			
			callback();
			return mapArr3;
		}
		const mapresult3 = mapArr2.mapLike(name => `${name}님`);
		console.log(mapresult3);

		// filter 콜백함수의 return ture(해당요소반환), false(반환하지 않음)
		const filterArr = [1,2,3,4];
		const filterresult1 = filterArr.filter(function(element, idx, arr){
			console.log(`요소 : ${element}, idx : ${idx}, target : ${arr}`);
			return (element % 2 == 1);
		});

		const filterresult2 = filterArr.filter(function(element, idx, arr){
			console.log(`요소 : ${element}, idx : ${idx}, target : ${arr}`);
			return  (element % 2 == 0);;
		});
		console.log(filterresult1);
		console.log(filterresult2);

		Array.prototype.filterLike = function(callback){
			// 새배열 생성
			returnArr =[];
			
			for(let i =0 ;i< this.length;i++) if(callback(this[i])) returnArr.push(this[i]);
				
				//if(callback(this[i])) returnArr.push(this[i]);
			
			//새배열 반환
			return returnArr;
		}

		filterresult3 = filterArr.filterLike(element => element %2 ==0)
									.map(element => element*2);
		console.log(filterresult3);
		
		// forEach 배열의 요소만큼 반복구문
		//배열이 가지고있는 요소만큼 콜백함수를 호출하는 메소드
		const forEachArr =[1,2,3,4];

		forEachArr.forEach(function(element, index,arr){
			console.log(`[${arr}]의 ${index}번째요소 : ${element}`)
		});
		
		// reduce 메소드(callback( 초기값 , 순회하는 요소 , 순회하는 요소의 인덱스 , 순회하는 배열 ){}, 초깃값);
		// reduce((acc, cur,idx, arr) =>{}, init);
		// 누적하는 메소드
		const reduceArr = [1,2,3,4];
				
		const total = reduceArr.reduce(function(acc,cur,idx,arr){
			console.log(`누적 : ${acc}, 요소 ${cur}, 인덱스${idx}, 배열 : ${arr}`);
			return acc+cur;
		},0);
		console.log(total);

		//reduceLike 메소드 확장하여 reduceLike를 구현하시오. // 고차함수 4가지 응용해보기
		const reduceArr1 = [100];
		Array.prototype.reduceLike = function(callback,init){
		let acc = init;
			for(let i = 0; i< this.length;i+=1){	
				if(i == 0 && acc === undefined){
					acc = this[i];
				}else{
					acc = callback(acc,this[i],i,this);
				}
			}
			return acc;
		}

			const exResult1 = reduceArr1.reduce(() => {});
			const exResult2 = reduceArr1.reduceLike(() => {});
			console.log(exResult1);
			console.log(exResult2);
		
	</script>
	 
	<h2>문자열 객체</h2>
	- 문자열을 생성하면 문자열 객체이다. 
	- 문자열을 생성하면 문자열 객체의 메서드를 사용 할 수 있다.
	<script type="text/javascript">
		let exStr1 = new String('ksmart51');
		let exStr2 = 'ksmart51';
		console.log(exStr1);
		console.log(exStr2);
		
		//indexOf : 찾으려는 문자열의 첫번째 인덱스번호를 반환한다.
		let exStr3 = '51기 경력자같은 신입개발자 51기';
		let exResult3 = exStr3.indexOf('50');
		console.log(exResult3);
		console.log(exResult3 > -1);

		// lastIndexOf : 찾으려는 문자열의 대상 문자열 뒤부터 찾아 
		//              인덱스번호 반환
		let exStr4 = '51기 경력자같은 신입개발자 51기';
		let exResult4 = exStr3.lastIndexOf('51');
		console.log(exResult4);

		// match 문자열을 왼쪽부터 찾을 문자와 일치하는 문자를 찾아 찾은 문자를 반환
		let exStr5 = '51기 경력자같은 신입개발자 51기';
		let exResult5 = exStr5.match(/51기/gi);
		console.log(exResult5);

		// replace 문자열을 왼쪽부터 검색한뒤 두번째 인수값으로 교체
		let exStr6 = '51기 경력자같은 신입개발자 51기';
		let exResult6 = exStr6.replace('51','오십일');
		let exResult7 = exStr6.replaceAll('51','오십일');
		console.log(exStr6);
		console.log(exResult6);
		console.log(exResult7);

		// search 문자열에서 왼쪽부터 찾을 문자와 일치하는 문자를 찾아
		// 제일 먼저 일치하는 인덱스번호를 반환합니다.
		let exStr7 = '51기 경력자같은 신입개발자 51기';
		exResult7 = exStr7.search('51');
		console.log(exResult7);

		// subString(시작할 인덱스, 종료 인덱스) - 기억
		let exStr8 = '51기 경력자같은 신입개발자 51기';
		exResult8 = exStr8.substring(4);
		console.log(exResult8);
		exResult8 = exStr8.substring(4,7);
		console.log(exResult8);

		// substr(시작할 인덱스, 추출할 문자갯수)
		let exStr9 = '51기 경력자같은 신입개발자 51기';
		exResult9 = exStr9.substr(4,7);
		console.log(exResult9);

		// split(구분자) 문자 ->구분자를 기준으로 새로운 배열 반환
		let exStr10 = '51기 경력자같은 신입개발자 51기';
		exResult10 = exStr10.split('경력자같은');
		console.log(exResult10);
		exResult10 = exStr10.split('51');
		console.log(exResult10);
		exResult10 = exStr10.split('');
		console.log(exResult10);
		exResult10 = exStr10.split();
		console.log(exResult10);
		exResult10 = exStr10.split(' ');
		console.log(exResult10);

		// String은 유사배열이기에 length 프로퍼티를 가진다.
		let exStr11 = '51기 경력자같은 신입개발자 51기';
		console.log(exStr11.length);

		// trim : 좌 우 해당되는 공백만 제거
		let exStr12 = '             51기 경력자같은 신입개발자 51기                       ';
		exResult12 = exStr12.trim();
		console.log(exStr12);
		console.log(exResult12);
		// 전체 문자열의 공백 제거
		//replaceAll
		exResult13 = exStr12.replaceAll(' ','');
		console.log(exResult13);
		//replace
		exResult14 = exStr12.replace(/\s/g,'');
		console.log(exResult14);
		//split, join
		exResult15 = exStr12.split(' ').join('');
		console.log(exResult15);

		
	</script>
</body>
</html>